<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VR Projectile Motion Simulator for Meta Quest 3 — Movement + Green Ground</title>
    <!-- Three.js (non-module builds so it works in sandboxes/Quest Browser) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <!-- Correct path for non-module VRButton (even though we don't use it directly) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Sky.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; -webkit-tap-highlight-color: transparent; }
        body { background: linear-gradient(135deg, #1a2a6c, #b21f1f); color: #fff; min-height: 100vh; padding: 20px; display: flex; flex-direction: column; align-items: center; overflow-x: hidden; }
        .container { max-width: 1200px; width: 100%; }
        header { text-align: center; padding: 20px 0; margin-bottom: 20px; }
        h1 { font-size: 2.8rem; margin-bottom: 10px; text-shadow: 0 2px 10px rgba(0,0,0,0.3); background: linear-gradient(to right, #ff8a00, #da1b60); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { font-size: 1.2rem; max-width: 600px; margin: 0 auto; opacity: 0.9; }
        .device-notice { background: rgba(255, 255, 255, 0.1); border-radius: 10px; padding: 15px; margin: 15px 0; text-align: center; }
        .simulation-container { display: flex; flex-wrap: wrap; gap: 25px; margin-bottom: 30px; }
        .canvas-wrapper { flex: 1; min-width: 300px; background: rgba(0, 0, 30, 0.8); border-radius: 16px; padding: 20px; box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.15); height: 500px; position: relative; overflow: hidden; }
        #vr-container { width: 100%; height: 100%; border-radius: 12px; overflow: hidden; }
        .controls { flex: 1; min-width: 300px; background: rgba(0, 0, 30, 0.8); border-radius: 16px; padding: 25px; box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.15); }
        .control-group { margin-bottom: 25px; }
        .control-title { font-size: 1.5rem; margin-bottom: 20px; color: #ff8a00; display: flex; align-items: center; gap: 12px; }
        .control-title i { font-size: 1.8rem; }
        .slider-container { margin-bottom: 18px; }
        label { display: block; margin-bottom: 10px; font-weight: 500; display: flex; justify-content: space-between; font-size: 1.1rem; }
        .value-display { font-weight: bold; color: #ff8a00; min-width: 80px; text-align: right; }
        input[type="range"] { width: 100%; height: 12px; background: linear-gradient(to right, #1a2a6c, #b21f1f); border-radius: 6px; outline: none; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 26px; height: 26px; border-radius: 50%; background: #ff8a00; cursor: pointer; box-shadow: 0 0 15px rgba(255, 138, 0, 0.8); transition: all 0.2s ease; }
        input[type="range"]::-webkit-slider-thumb:active { transform: scale(1.2); }
        .toggle-container { display: flex; align-items: center; justify-content: space-between; margin-bottom: 18px; padding: 10px 0; }
        .toggle-label { display: flex; align-items: center; gap: 12px; font-weight: 500; font-size: 1.1rem; }
        .switch { position: relative; display: inline-block; width: 65px; height: 32px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #1a2a6c; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 4px; bottom: 4px; background: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background: #ff8a00; }
        input:checked + .slider:before { transform: translateX(32px); }
        .button-group { display: flex; gap: 18px; margin-top: 25px; }
        button { flex: 1; padding: 16px; border: none; border-radius: 14px; font-size: 1.2rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; background: linear-gradient(to right, #ff8a00, #da1b60); color: white; box-shadow: 0 6px 20px rgba(218, 27, 96, 0.4); display: flex; align-items: center; justify-content: center; gap: 10px; }
        button:active { transform: translateY(4px); box-shadow: 0 3px 10px rgba(218, 27, 96, 0.3); }
        #resetBtn { background: linear-gradient(to right, #1a2a6c, #4a00e0); box-shadow: 0 6px 20px rgba(26, 42, 108, 0.4); }
        #vrBtn { background: linear-gradient(to right, #00c9ff, #92fe9d); color: #000; box-shadow: 0 6px 20px rgba(0, 201, 255, 0.4); }
        .results { background: rgba(0, 0, 30, 0.8); border-radius: 16px; padding: 25px; margin-bottom: 30px; box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.15); }
        .results h2 { font-size: 1.8rem; margin-bottom: 20px; color: #ff8a00; display: flex; align-items: center; gap: 12px; }
        .results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; }
        .result-card { background: rgba(26, 42, 108, 0.5); padding: 20px; border-radius: 14px; text-align: center; transition: transform 0.3s ease; }
        .result-card:hover { transform: translateY(-5px); background: rgba(26, 42, 108, 0.7); }
        .result-value { font-size: 2.4rem; font-weight: 700; margin: 10px 0; color: #ff8a00; }
        .result-label { font-size: 1.1rem; opacity: 0.9; }
        .info-panel { position: absolute; top: 20px; right: 20px; background: rgba(0, 5, 25, 0.9); border-radius: 14px; padding: 18px; width: 250px; border: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4); z-index: 10; }
        .info-title { color: #ff8a00; font-size: 1.3rem; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
        .info-item { display: flex; justify-content: space-between; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.15); }
        .info-label { color: #a0a0ff; }
        .info-value { font-weight: 600; color: #ff8a00; }
        .vr-controls { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 10px; z-index: 20; }
        .vr-controls button { padding: 10px 15px; font-size: 0.9rem; }
        .vr-instruction { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.7); padding: 20px; border-radius: 10px; text-align: center; z-index: 15; max-width: 80%; }
        .vr-instruction.hidden { display: none; }
        .diag { position: absolute; left: 12px; top: 12px; z-index: 30; font-size: 12px; background: rgba(0,0,0,.45); padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,.15); }
        footer { text-align: center; padding: 20px; opacity: 0.8; font-size: 1rem; margin-top: 20px; }
        @media (hover: none) and (pointer: coarse) { .device-notice { display: block; } }
        @media (max-width: 768px) { .simulation-container { flex-direction: column; } h1 { font-size: 2.3rem; } .control-title { font-size: 1.3rem; } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>VR Projectile Motion Simulator</h1>
            <p class="subtitle">Immersive 3D Experience for Meta Quest 3</p>
            <div class="device-notice"><i class="fas fa-vr-cardboard"></i><p>Put on your Meta Quest 3 headset for the full VR experience!</p></div>
        </header>
        <div class="simulation-container">
            <div class="canvas-wrapper">
                <div class="info-panel">
                    <div class="info-title"><i class="fas fa-rocket"></i><span>Flight Data</span></div>
                    <div class="info-item"><span class="info-label">Time:</span><span class="info-value" id="infoTime">0.0s</span></div>
                    <div class="info-item"><span class="info-label">Height:</span><span class="info-value" id="infoHeight">0.0m</span></div>
                    <div class="info-item"><span class="info-label">Distance:</span><span class="info-value" id="infoDistance">0.0m</span></div>
                    <div class="info-item"><span class="info-label">Speed:</span><span class="info-value" id="infoSpeed">0.0m/s</span></div>
                </div>
                <div id="vr-container"></div>
                <div class="diag" id="diag">starting…</div>
                <div class="vr-controls">
                    <button id="vrBtn"><i class="fas fa-vr-cardboard"></i> Enter VR</button>
                    <button id="resetViewBtn"><i class="fas fa-sync"></i> Reset View</button>
                </div>
                <div class="vr-instruction hidden" id="vrInstruction">
                    <h3>Welcome to VR Mode!</h3>
                    <p>Use left thumbstick to move, right thumbstick to snap-turn</p>
                    <p>Press trigger to launch projectile</p>
                </div>
            </div>
            <div class="controls">
                <div class="control-group">
                    <h3 class="control-title"><i class="fas fa-sliders-h"></i><span>Launch Parameters</span></h3>
                    <div class="slider-container"><label><span>Velocity</span><span class="value-display" id="velValue">25 m/s</span></label><input type="range" id="velocity" min="5" max="50" value="25" step="1" /></div>
                    <div class="slider-container"><label><span>Angle</span><span class="value-display" id="angleValue">45°</span></label><input type="range" id="angle" min="0" max="90" value="45" step="1" /></div>
                    <div class="slider-container"><label><span>Height</span><span class="value-display" id="heightValue">1.5 m</span></label><input type="range" id="height" min="0" max="50" value="1.5" step="0.5" /></div>
                </div>
                <div class="control-group">
                    <h3 class="control-title"><i class="fas fa-wind"></i><span>Environment Settings</span></h3>
                    <div class="toggle-container"><div class="toggle-label"><i class="fas fa-fan"></i><span>Air Resistance</span></div><label class="switch"><input type="checkbox" id="airRes" checked /><span class="slider"></span></label></div>
                    <div class="slider-container"><label><span>Gravity</span><span class="value-display" id="gravityValue">9.81 m/s²</span></label><input type="range" id="gravity" min="1" max="20" value="9.81" step="0.1" /></div>
                    <div class="slider-container"><label><span>Wind</span><span class="value-display" id="windValue">0.0 m/s</span></label><input type="range" id="wind" min="-10" max="10" value="0" step="0.5" /></div>
                </div>
                <div class="button-group"><button id="runBtn"><i class="fas fa-play"></i> Launch Projectile</button><button id="resetBtn"><i class="fas fa-redo"></i> Reset</button></div>
            </div>
        </div>
        <div class="results">
            <h2><i class="fas fa-chart-line"></i><span>Simulation Results</span></h2>
            <div class="results-grid">
                <div class="result-card"><div class="result-value" id="maxHeight">0.0 m</div><div class="result-label">Max Height</div></div>
                <div class="result-card"><div class="result-value" id="distance">0.0 m</div><div class="result-label">Distance</div></div>
                <div class="result-card"><div class="result-value" id="flightTime">0.0 s</div><div class="result-label">Flight Time</div></div>
                <div class="result-card"><div class="result-value" id="impactSpeed">0.0 m/s</div><div class="result-label">Impact Speed</div></div>
            </div>
        </div>
        <footer><p>VR Projectile Motion Simulator | Optimized for Meta Quest 3</p></footer>
    </div>

    <script>
    // ===== Physics constants =====
    const AIR_DENSITY = 1.2; const DRAG_COEFFICIENT = 0.5; const CROSS_SECTIONAL_AREA = 0.1; const TIME_STEP = 0.02;
    // Simulation state
    let animationId = null, trajectory = [], isRunning = false, currentFrame = 0, vrSession = null;
    // Parameters
    let params = { velocity: 25, angle: 45, height: 1.5, airResistance: true, gravity: 9.81, wind: 0.0 };
    // Results
    let results = { maxHeight: 0, distance: 0, flightTime: 0, impactSpeed: 0 };

    // ===== DOM elements =====
    const velocitySlider = document.getElementById('velocity');
    const angleSlider = document.getElementById('angle');
    const heightSlider = document.getElementById('height');
    const airResToggle = document.getElementById('airRes');
    const gravitySlider = document.getElementById('gravity');
    const windSlider = document.getElementById('wind');
    const runBtn = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');
    const vrBtn = document.getElementById('vrBtn');
    const resetViewBtn = document.getElementById('resetViewBtn');
    const vrInstruction = document.getElementById('vrInstruction');
    const diag = document.getElementById('diag');

    // ===== Three.js variables =====
    let scene, camera, renderer, controls;
    let projectile, trajectoryLine, ground;
    let isInVR = false; let vrUIContainer, vrControllers = [];
    let controller1, controller2, controllerGrip1, controllerGrip2;

    // New: player rig + locomotion helpers
    const player = new THREE.Group(); // move this, not the scene
    const clock = new THREE.Clock();
    const up = new THREE.Vector3(0,1,0); const vForward = new THREE.Vector3(); const vSide = new THREE.Vector3();
    const WALK_SPEED = 2.0; // meters/second
    const SNAP_TURN = THREE.MathUtils.degToRad(30); let turnCooldown = 0; // sec (FIXED: use MathUtils)

    function log(s){ if (diag) diag.textContent = s; console.log('[VR]', s); }

    function initThreeScene() {
        // Scene
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);
        // Renderer
        const container = document.getElementById('vr-container');
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true; // Enable WebXR
        if (renderer.xr.setReferenceSpaceType) renderer.xr.setReferenceSpaceType('local-floor'); // <-- important for floor height
        renderer.shadowMap.enabled = true; container.appendChild(renderer.domElement);

        // XR session events
        renderer.xr.addEventListener('sessionstart', () => {
            isInVR = true; log('sessionstart'); vrBtn.innerHTML = '<i class="fas fa-vr-cardboard"></i> Exit VR'; vrInstruction.classList.remove('hidden'); setTimeout(()=>vrInstruction.classList.add('hidden'), 4000);
            createVRUI(); setupControllers(); controls.enabled = false;
        });
        renderer.xr.addEventListener('sessionend', () => {
            isInVR = false; log('sessionend'); vrBtn.innerHTML = '<i class="fas fa-vr-cardboard"></i> Enter VR'; controls.enabled = true;
            if (vrUIContainer) scene.remove(vrUIContainer);
            [controller1, controller2, controllerGrip1, controllerGrip2].forEach(c => c && scene.remove(c));
        });

        // Lights
        scene.add(new THREE.AmbientLight(0x404040));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5,10,7); directionalLight.castShadow = true; scene.add(directionalLight);

        // Controls (non-VR only)
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false; controls.minDistance = 3; controls.maxDistance = 50; controls.maxPolarAngle = Math.PI/2 - 0.1;

        // Player rig: add to scene and put camera inside it
        scene.add(player); player.add(camera);

        // Ground: GREEN grass texture (as requested)
        const textureLoader = new THREE.TextureLoader();
        const grassTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping; grassTexture.repeat.set(20, 20);
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 0.95, metalness: 0.0 });
        ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

        // Sky
        const sky = new THREE.Sky(); sky.scale.setScalar(10000); scene.add(sky);
        const skyUniforms = sky.material.uniforms; skyUniforms['turbidity'].value = 10; skyUniforms['rayleigh'].value = 2; skyUniforms['mieCoefficient'].value = 0.005; skyUniforms['mieDirectionalG'].value = 0.8;
        const sun = new THREE.Vector3(); const theta = Math.PI * 0.49, phi = 2 * Math.PI * 0.25; sun.setFromSphericalCoords(1, theta, phi); skyUniforms['sunPosition'].value.copy(sun);

        // Trees + grid
        addEnvironmentElements(); const gridHelper = new THREE.GridHelper(200, 40, 0xffffff, 0xffffff); gridHelper.material.opacity = 0.15; gridHelper.material.transparent = true; scene.add(gridHelper);

        // Projectile + trajectory
        const sphereGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0xff8a00, emissive: 0xff5500, emissiveIntensity: 0.5, metalness: 0.7, roughness: 0.3 });
        projectile = new THREE.Mesh(sphereGeometry, sphereMaterial); projectile.castShadow = true; scene.add(projectile);
        const trajectoryGeometry = new THREE.BufferGeometry(); const trajectoryMaterial = new THREE.LineBasicMaterial({ color: 0x00c9ff, linewidth: 2, transparent: true, opacity: 0.7 });
        trajectoryLine = new THREE.Line(trajectoryGeometry, trajectoryMaterial); scene.add(trajectoryLine);

        // Launcher + start
        createLauncher(); resetProjectilePosition();
        window.addEventListener('resize', onWindowResize);

        // IMPORTANT: one animation loop for both flat and VR (prevents blank screen in VR)
        renderer.setAnimationLoop(mainLoop);
        log('ready');
    }

    function createLauncher(){
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.2,32), new THREE.MeshStandardMaterial({ color: 0x333333 })); base.position.set(0,0.1,0); scene.add(base);
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,2,32), new THREE.MeshStandardMaterial({ color: 0x666666 })); barrel.position.set(0,1,0); barrel.rotation.z = -Math.PI/2; scene.add(barrel);
        const standGeo = new THREE.BoxGeometry(0.1,1.8,0.1); const standMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const s1 = new THREE.Mesh(standGeo, standMat); s1.position.set(-0.3,0.9,0); scene.add(s1);
        const s2 = new THREE.Mesh(standGeo, standMat); s2.position.set(0.3,0.9,0); scene.add(s2);
    }

    function resetProjectilePosition(){ projectile.position.set(0, params.height, 0); updateTrajectoryLine(); }

    function updateTrajectoryLine(){
        const pts = []; const rad = params.angle * Math.PI/180; let vx = params.velocity * Math.cos(rad); let vy = params.velocity * Math.sin(rad); let x = 0; let y = params.height; const k = params.airResistance ? 0.5 * AIR_DENSITY * DRAG_COEFFICIENT * CROSS_SECTIONAL_AREA : 0; pts.push(new THREE.Vector3(x,y,0));
        while (y > 0) { const speed = Math.sqrt(vx*vx + vy*vy); const drag = k * speed * speed; const ax = -drag * (vx / speed) + params.wind; const ay = -params.gravity - drag * (vy / speed); vx += ax * TIME_STEP; vy += ay * TIME_STEP; x += vx * TIME_STEP; y += vy * TIME_STEP; pts.push(new THREE.Vector3(x,y,0)); if (pts.length > 1000) break; }
        trajectoryLine.geometry = new THREE.BufferGeometry().setFromPoints(pts);
    }

    function onWindowResize(){ const container = document.getElementById('vr-container'); camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight); }

    function renderScene(){
        if (isRunning && trajectory.length > 0 && currentFrame < trajectory.length) {
            const p = trajectory[currentFrame]; projectile.position.set(p.x, p.y, 0); const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy); updateInfoPanel(currentFrame * TIME_STEP, p.y, p.x, speed); currentFrame++; }
        if (!isInVR) { controls.update(); }
        renderer.render(scene, camera);
    }

    function mainLoop(){
        const dt = clock.getDelta();
        if (renderer.xr.isPresenting) { // in VR
            pollInputs(dt);
        }
        renderScene();
    }

    // === VR UI ===
    function createVRUI(){
        vrUIContainer = new THREE.Group(); scene.add(vrUIContainer); vrUIContainer.position.set(0, 1.5, -2);
        const panel = new THREE.Mesh(new THREE.PlaneGeometry(4, 4.5), new THREE.MeshBasicMaterial({ color: 0x1a2a6c, transparent: true, opacity: 0.8, side: THREE.DoubleSide })); vrUIContainer.add(panel);
        const loader = new THREE.FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font){
            const title = new THREE.Mesh(new THREE.TextGeometry('VR Controls', { font, size: 0.15, height: 0.01 }), new THREE.MeshBasicMaterial({ color: 0xff8a00 })); title.position.set(-1.2, 1.7, 0.1); vrUIContainer.add(title);
            const labelMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const makeLabel = (text, x, y, tag)=>{ const m = new THREE.Mesh(new THREE.TextGeometry(text, { font, size: 0.08, height: 0.01 }), labelMat); m.position.set(x,y,0.1); m.userData = { type:'label', param: tag }; vrUIContainer.add(m); return m; };
            makeLabel('Velocity: '+params.velocity+' m/s', -1.7, 1.1, 'velocity');
            createButton('-', -1.7, 0.9, 'velocity', -1); createButton('+', -1.1, 0.9, 'velocity', 1);
            makeLabel('Angle: '+params.angle+'°', -1.7, 0.6, 'angle');
            createButton('-', -1.7, 0.4, 'angle', -1); createButton('+', -1.1, 0.4, 'angle', 1);
            makeLabel('Height: '+params.height+' m', -1.7, 0.1, 'height');
            createButton('-', -1.7, -0.1, 'height', -0.5); createButton('+', -1.1, -0.1, 'height', 0.5);
            makeLabel('Gravity: '+params.gravity.toFixed(2)+' m/s²', -1.7, -0.4, 'gravity');
            createButton('-', -1.7, -0.6, 'gravity', -0.1); createButton('+', -1.1, -0.6, 'gravity', 0.1);
            makeLabel('Wind: '+params.wind.toFixed(1)+' m/s', -1.7, -0.9, 'wind');
            createButton('-', -1.7, -1.1, 'wind', -0.5); createButton('+', -1.1, -1.1, 'wind', 0.5);
            makeLabel('Air Resistance: '+(params.airResistance?'On':'Off'), -1.7, -1.4, 'airRes');
            createButton('Toggle', -1.1, -1.4, 'airResToggle');
            const btnGeo = new THREE.BoxGeometry(0.8, 0.2, 0.05); const btnMat = new THREE.MeshBasicMaterial({ color: 0xff8a00 });
            const launchButton = new THREE.Mesh(btnGeo, btnMat); launchButton.position.set(0.8, -1.6, 0.05); launchButton.userData = { action: 'launch' }; vrUIContainer.add(launchButton);
            const resetButton = new THREE.Mesh(btnGeo, btnMat); resetButton.position.set(0.8, -1.9, 0.05); resetButton.userData = { action: 'reset' }; vrUIContainer.add(resetButton);
            const lt = new THREE.Mesh(new THREE.TextGeometry('Launch Projectile', { font, size: 0.07, height: 0.01 }), labelMat); lt.position.set(0.2, -1.62, 0.1); vrUIContainer.add(lt);
            const rt = new THREE.Mesh(new THREE.TextGeometry('Reset Simulation', { font, size: 0.07, height: 0.01 }), labelMat); rt.position.set(0.25, -1.92, 0.1); vrUIContainer.add(rt);
        });
    }

    function createButton(label, x, y, param, step = 0){
        const loader = new THREE.FontLoader(); const button = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.15,0.05), new THREE.MeshBasicMaterial({ color: 0xff8a00 })); button.position.set(x,y,0.05); button.userData = { param, step }; vrUIContainer.add(button);
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font){ const text = new THREE.Mesh(new THREE.TextGeometry(label, { font, size: 0.07, height: 0.01 }), new THREE.MeshBasicMaterial({ color: 0xffffff })); text.position.set(x - 0.1, y - 0.05, 0.1); vrUIContainer.add(text); });
        return button;
    }

    function updateVRUI(){ if (!vrUIContainer) return; vrUIContainer.children.forEach(child => { if (child.userData && child.userData.type === 'label') { const param = child.userData.param; let text=''; if (param==='velocity') text='Velocity: '+params.velocity+' m/s'; if (param==='angle') text='Angle: '+params.angle+'°'; if (param==='height') text='Height: '+params.height+' m'; if (param==='gravity') text='Gravity: '+params.gravity.toFixed(2)+' m/s²'; if (param==='wind') text='Wind: '+params.wind.toFixed(1)+' m/s'; if (param==='airRes') text='Air Resistance: '+(params.airResistance?'On':'Off'); const loader = new THREE.FontLoader(); loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font){ child.geometry = new THREE.TextGeometry(text, { font, size: 0.08, height: 0.01 }); }); } }); }

    // ===== Controllers & Locomotion =====
    function setupControllers(){
        controller1 = renderer.xr.getController(0); controller2 = renderer.xr.getController(1); player.add(controller1); player.add(controller2);
        controllerGrip1 = renderer.xr.getControllerGrip(0); controllerGrip2 = renderer.xr.getControllerGrip(1); player.add(controllerGrip1); player.add(controllerGrip2);
        const lineGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]); const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 }); const l1 = new THREE.Line(lineGeo, lineMat); l1.scale.z = 5; controller1.add(l1); const l2 = new THREE.Line(lineGeo, lineMat); l2.scale.z = 5; controller2.add(l2);
        controller1.addEventListener('selectstart', onSelectStart); controller1.addEventListener('selectend', onSelectEnd); controller2.addEventListener('selectstart', onSelectStart); controller2.addEventListener('selectend', onSelectEnd);
        // NOTE: We intentionally DO NOT use 'thumbstickchange' (doesn't fire in Quest). We poll axes each frame.
        vrControllers = [controller1, controller2];
    }

    function pollInputs(dt){
        const session = renderer.xr.getSession(); if (!session) return; if (turnCooldown>0) turnCooldown -= dt; const xrCam = renderer.xr.getCamera(camera);
        for (const src of session.inputSources){
            const gp = src && src.gamepad; if (!gp) continue; const ax = gp.axes || []; const lx = ax[0] || 0, ly = ax[1] || 0; const rx = ax[2] || 0; // ly forward/back, lx strafe, rx turn
            // Movement deadzone
            const dz = 0.15; const moving = Math.abs(lx)>dz || Math.abs(ly)>dz; const turning = Math.abs(rx) > 0.7; // snap
            if (moving){
                vForward.set(0,0,-1).applyQuaternion(xrCam.quaternion); vForward.y = 0; vForward.normalize(); vSide.copy(vForward).cross(up).normalize();
                player.position.addScaledVector(vForward, (-ly) * WALK_SPEED * dt);
                player.position.addScaledVector(vSide,    ( lx) * WALK_SPEED * dt);
            }
            if (turning && turnCooldown<=0){ const dir = Math.sign(rx); player.rotateOnWorldAxis(up, dir * SNAP_TURN); turnCooldown = 0.25; }
        }
    }

    function onSelectStart(event){
        const controller = event.target; const tempMatrix = new THREE.Matrix4(); tempMatrix.identity().extractRotation(controller.matrixWorld);
        const raycaster = new THREE.Raycaster(); raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld); raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);
        const intersects = raycaster.intersectObjects(vrUIContainer.children);
        if (intersects.length>0){ const object = intersects[0].object; if (object.userData && object.userData.action==='launch'){ runSimulation(); object.material && object.material.color && object.material.color.set(0x00ff00); }
        else if (object.userData && object.userData.action==='reset'){ resetSimulation(); object.material && object.material.color && object.material.color.set(0x00ff00); }
        else if (object.userData && object.userData.param){ const param = object.userData.param; const step = object.userData.step || 0; if (param==='airResToggle'){ params.airResistance = !params.airResistance; airResToggle.checked = params.airResistance; updateValueDisplays(); updateTrajectoryLine(); object.material && object.material.color && object.material.color.set(0x00ff00); } else { if (param==='velocity'){ params.velocity = Math.max(5, Math.min(50, params.velocity + step)); velocitySlider.value = params.velocity; } if (param==='angle'){ params.angle = Math.max(0, Math.min(90, params.angle + step)); angleSlider.value = params.angle; } if (param==='height'){ params.height = Math.max(0, Math.min(50, params.height + step)); heightSlider.value = params.height; } if (param==='gravity'){ params.gravity = Math.max(1, Math.min(20, params.gravity + step)); gravitySlider.value = params.gravity; } if (param==='wind'){ params.wind = Math.max(-10, Math.min(10, params.wind + step)); windSlider.value = params.wind; } updateValueDisplays(); updateTrajectoryLine(); object.material && object.material.color && object.material.color.set(0x00ff00); } } }
    }
    function onSelectEnd(){ if (vrUIContainer){ vrUIContainer.children.forEach(child=>{ if (child.material && child.material.color){ child.material.color.set(0xff8a00); } }); } }

    function addEnvironmentElements(){
        const treeGroup = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.4,2,8), new THREE.MeshStandardMaterial({ color: 0x8B4513 })); trunk.position.y = 1; trunk.castShadow = true; trunk.receiveShadow = true; treeGroup.add(trunk);
        const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5,4,8), new THREE.MeshStandardMaterial({ color: 0x228B22 })); leaves.position.y = 4; leaves.castShadow = true; leaves.receiveShadow = true; treeGroup.add(leaves);
        [{x:15,z:10},{x:-12,z:8},{x:8,z:-15},{x:-10,z:-12},{x:20,z:-5},{x:-18,z:3}].forEach(pos=>{ const t = treeGroup.clone(); t.position.set(pos.x,0,pos.z); scene.add(t); });
    }

    // ===== Trajectory & UI updates =====
    function calculateTrajectory(){ const pts=[]; let maxH=0; const rad=params.angle*Math.PI/180; let vx=params.velocity*Math.cos(rad), vy=params.velocity*Math.sin(rad); let x=0, y=params.height; const k=params.airResistance?0.5*AIR_DENSITY*DRAG_COEFFICIENT*CROSS_SECTIONAL_AREA:0; pts.push({x,y,vx,vy}); while(y>0){ const s=Math.sqrt(vx*vx+vy*vy); const drag=k*s*s; const ax=-drag*(vx/s)+params.wind; const ay=-params.gravity - drag*(vy/s); vx+=ax*TIME_STEP; vy+=ay*TIME_STEP; x+=vx*TIME_STEP; y+=vy*TIME_STEP; if(y>maxH) maxH=y; pts.push({x,y,vx,vy}); if(pts.length>1000) break; } return {points:pts, maxHeight:maxH}; }
    function updateValueDisplays(){ document.getElementById('velValue').textContent = params.velocity+' m/s'; document.getElementById('angleValue').textContent = params.angle+'°'; document.getElementById('heightValue').textContent = params.height+' m'; document.getElementById('gravityValue').textContent = params.gravity.toFixed(2)+' m/s²'; document.getElementById('windValue').textContent = params.wind.toFixed(1)+' m/s'; if (isInVR) updateVRUI(); }
    function updateResultsDisplay(){ document.getElementById('maxHeight').textContent = results.maxHeight.toFixed(1)+' m'; document.getElementById('distance').textContent = results.distance.toFixed(1)+' m'; document.getElementById('flightTime').textContent = results.flightTime.toFixed(1)+' s'; document.getElementById('impactSpeed').textContent = results.impactSpeed.toFixed(1)+' m/s'; }
    function updateInfoPanel(time, height, distance, speed){ document.getElementById('infoTime').textContent = time.toFixed(1)+'s'; document.getElementById('infoHeight').textContent = height.toFixed(1)+'m'; document.getElementById('infoDistance').textContent = distance.toFixed(1)+'m'; document.getElementById('infoSpeed').textContent = speed.toFixed(1)+'m/s'; }

    function runSimulation(){ if (isRunning) return; params.velocity=parseInt(velocitySlider.value); params.angle=parseInt(angleSlider.value); params.height=parseFloat(heightSlider.value); params.airResistance=airResToggle.checked; params.gravity=parseFloat(gravitySlider.value); params.wind=parseFloat(windSlider.value); updateValueDisplays(); updateTrajectoryLine(); results={maxHeight:0,distance:0,flightTime:0,impactSpeed:0}; const data=calculateTrajectory(); trajectory=data.points; currentFrame=0; isRunning=true; runBtn.innerHTML='<i class="fas fa-sync-alt"></i> Running...'; if (trajectory.length>0){ const last=trajectory[trajectory.length-1]; results.distance=last.x; results.impactSpeed=Math.sqrt(last.vx*last.vx+last.vy*last.vy); results.flightTime=trajectory.length*TIME_STEP; results.maxHeight=data.maxHeight; } updateResultsDisplay(); }
    function resetSimulation(){ params={ velocity:25, angle:45, height:1.5, airResistance:true, gravity:9.81, wind:0.0 }; velocitySlider.value=params.velocity; angleSlider.value=params.angle; heightSlider.value=params.height; airResToggle.checked=params.airResistance; gravitySlider.value=params.gravity; windSlider.value=params.wind; trajectory=[]; isRunning=false; currentFrame=0; runBtn.innerHTML='<i class="fas fa-play"></i> Launch Projectile'; resetProjectilePosition(); document.getElementById('infoTime').textContent='0.0s'; document.getElementById('infoHeight').textContent='0.0m'; document.getElementById('infoDistance').textContent='0.0m'; document.getElementById('infoSpeed').textContent='0.0m/s'; updateValueDisplays(); updateResultsDisplay(); }

    async function toggleVR(){
        if (!navigator.xr) { alert('WebXR not supported in this browser.'); return; }
        if (isInVR){
            try { if (vrSession) await vrSession.end(); } catch(e) { console.warn('end session', e); }
        } else {
            try {
                const sessionInit = { optionalFeatures: ['local-floor','bounded-floor','hand-tracking'] };
                vrSession = await navigator.xr.requestSession('immersive-vr', sessionInit);
                await renderer.xr.setSession(vrSession);
                vrSession.addEventListener('end', ()=>{ vrSession=null; isInVR=false; vrBtn.innerHTML='<i class="fas fa-vr-cardboard"></i> Enter VR'; });
            } catch(err){ console.error('Error starting VR', err); alert('Failed to start VR: '+err.message); }
        }
    }

    function resetView(){ // reset player/camera for both flat and VR
        player.position.set(0,0,0); player.rotation.set(0,0,0); camera.position.set(0,1.6,5); camera.lookAt(0,1.3,0);
    }

    // ===== Event listeners =====
    runBtn.addEventListener('click', runSimulation); resetBtn.addEventListener('click', resetSimulation); resetViewBtn.addEventListener('click', resetView); vrBtn.addEventListener('click', toggleVR);
    velocitySlider.addEventListener('input', function(){ params.velocity=parseInt(this.value); updateValueDisplays(); updateTrajectoryLine(); });
    angleSlider.addEventListener('input', function(){ params.angle=parseInt(this.value); updateValueDisplays(); updateTrajectoryLine(); });
    heightSlider.addEventListener('input', function(){ params.height=parseFloat(this.value); updateValueDisplays(); updateTrajectoryLine(); });
    gravitySlider.addEventListener('input', function(){ params.gravity=parseFloat(this.value); updateValueDisplays(); updateTrajectoryLine(); });
    windSlider.addEventListener('input', function(){ params.wind=parseFloat(this.value); updateValueDisplays(); updateTrajectoryLine(); });
    airResToggle.addEventListener('change', function(){ params.airResistance=this.checked; updateValueDisplays(); updateTrajectoryLine(); });

    // ===== Init =====
    window.addEventListener('load', function(){
        initThreeScene(); updateValueDisplays(); updateResultsDisplay();
        if (!navigator.xr){ vrBtn.disabled = true; vrBtn.textContent = 'WebXR not supported'; log('WebXR not supported'); }
        if (/Quest/.test(navigator.userAgent)) { vrInstruction.innerHTML = '<h3>Welcome to Meta Quest 3!</h3><p>Use left thumbstick to move, right to snap-turn</p><p>Press trigger to launch projectile</p>'; }
    });
    </script>

    <!-- Font Awesome -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
</body>
</html>
